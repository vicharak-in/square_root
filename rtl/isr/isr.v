// =============================================================================
// Generated by efx_ipmgr
// Version: 2024.1.163
// IP Version: 5.1
// =============================================================================

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2024 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//                                                                       
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//                                                                       
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.                                                
//
////////////////////////////////////////////////////////////////////////////////

`define IP_UUID _b488723abaf443efb0205eac3edf8722
`define IP_NAME_CONCAT(a,b) a``b
`define IP_MODULE_NAME(name) `IP_NAME_CONCAT(name,`IP_UUID)
module isr
(
    input reset_n,
    input sysclk,
    input [255:0] din,
    input calcen,
    input clken,
    output [127:0] vout,
    output [128:0] rout,
    output calcend,
    output sqrtidle
);
`IP_MODULE_NAME(sqrt_top)
#(
    .MODE_C ("CONTIN"),
    .PIPELINENUM_C (2),
    .DATAWIDTH_C (256),
    .ALUNUMBER (2)
)
u_sqrt_top
(
    .reset_n ( reset_n ),
    .sysclk ( sysclk ),
    .din ( din ),
    .calcen ( calcen ),
    .clken ( clken ),
    .vout ( vout ),
    .rout ( rout ),
    .calcend ( calcend ),
    .sqrtidle ( sqrtidle )
);
endmodule

/////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2013-2019 Efinix Inc. All rights reserved.
//
// sqrt.v
//
// Description:
// Square root module
//
// *******************************
// Revisions:
// 1.0 Initial rev
// 1.1 Fixed a bug on CalcEnSftReg
//
// *******************************
/////////////////////////////////////////////////////////////////////////////

`timescale 100ps/10ps

/*
*	Definition:
*	
*	din = vout * vout + rout
*		where vout is the largest possible integer,
*		din and rout are both integers
*
*	din - input value
*	vout - value output
*	rout - remainder output
*/ 

/*
*  Main module
*/ 
module `IP_MODULE_NAME(sqrt_top)
(   
	//System Signal                                         
	sysclk,		//System Clock
	reset_n,	//System Reset
	
	//Data Signal
	din,		//Data Input
	vout,		//Value Output
	rout,		//Remainder Output

	//Control & State Signal
	clken,		//Clock Eanble
	calcen,		//Calculate Enable
	calcend,	//Calculate End
	sqrtidle	//SQRT Idle
);

		//Define parameters
	/*
	*	2 modes: "CONTIN" - continuous, "SINGLE" -Single
	*	CONTIN -continuous
	*		High Speed and Mass data is required 
	*	SINGLE -single
	*		Smallest resourced and Low Speed Data is Required 
	*/	
   parameter MODE_C = "SINGLE";
 
								
	//parameter PIPELINENUM_C = 17,	//Pipeline number
   parameter PIPELINENUM_C = 1;            
	//Pipeline number
   parameter DATAWIDTH_C = 40;
	//Data width
   parameter ALUNUMBER = 2;
	//ALU number, for SINGLE mode only
	//Define local parameters       
	localparam DInW_C = DATAWIDTH_C;			//Input data width            
	localparam DW_C = DATAWIDTH_C + (DATAWIDTH_C%2);	//Internal data width  
	localparam VW_C = DW_C/2;				//Value width                      
	localparam RW_C = DW_C/2+1;				//Remainder width
	localparam RN_C = DW_C/2;				//Repeat number                      

	//Define Port
	input sysclk;			//System Clock
	input reset_n;			//System Reset (active low)
	
	input [DInW_C-1:0] din;		//Data Input
	output [VW_C-1:0] vout;		//Value Output
	output [RW_C-1:0] rout;		//Remainder Output
	
	input clken;			//Clock Enable
	input calcen;			//Calculate Enable
	output sqrtidle;		//SQRT Idle
	output calcend;			//Calculate End
		
	//local wire		
	wire [VW_C-1:0] vout;		//Value Output
	wire [RW_C-1:0] rout;		//Remainder Output
	
	wire sqrtidle;			//SQRT Idle
	wire calcend;			//Calculate End
	
	generate 
		if (MODE_C == "CONTIN") begin	// continuous mode
			`IP_MODULE_NAME(SqrtContin) 
			#(
				.PIPELINENUM_C	(PIPELINENUM_C),
				.DATAWIDTH_C	(DATAWIDTH_C)
			)               
			U1_SqrtContin
			(   
				//System Signal
				.sysclk		(sysclk),	//System Clock
				.reset_n	(reset_n),	//System Reset
				//Data Signal
				.din		(din),		//Data Input
				.vout		(vout),		//Value Output
				.rout		(rout),		//Remainder Output
				//Control & State Signal
				.clken		(clken),	//Clock Eanble
				.calcen		(calcen),	//Calculate Enable
				.calcend 	(calcend),	//Calculate End
				.sqrtidle	(sqrtidle)	//SQRT Idle
			);
		end
		else begin			// single mode
			`IP_MODULE_NAME(SqrtSimple)	
			#(
				.ALUNUMBER	(ALUNUMBER),
				.DATAWIDTH_C	(DATAWIDTH_C)
			)
			U1_SqrtSimple
			(   
				//System Signal
				.sysclk		(sysclk),	//System Clock
				.reset_n	(reset_n),	//System Reset
				//Data Signal     	
				.din		(din),		//Data Input
				.vout		(vout),		//Value Output
				.rout		(rout),		//Remainder Output
				//Control & State Signal
				.clken		(clken),	//Clock Eanble
				.calcen		(calcen),	//Calculate Enable
				.calcend 	(calcend),	//Calculate End
				.sqrtidle	(sqrtidle)	//SQRT Idle
			);
		end
	endgenerate

endmodule 


/*
*  module for continuous mode
*/
module `IP_MODULE_NAME(SqrtContin)
#(
 	//Define parameters
	//parameter PIPELINENUM_C = 16,		//Pipeline Number
	parameter PIPELINENUM_C = 1,		//Pipeline Number
	parameter DATAWIDTH_C = 40		//Input data width
)

(   
	//System Signal
	sysclk,		//System Clock
	reset_n,	//System Reset
	//Data Signal
	din,		//Data Input
	vout,		//Value Output
	rout,		//Remainder Output
	//Control & State Signal
	clken,		//Clock Eanble
	calcen,		//Calculate Enable
	calcend,	//Calculate End
	sqrtidle	//SQRT Idle
);

	//Define local parameters
	localparam DInW_C = DATAWIDTH_C;			//Input data width
	localparam DW_C	= DATAWIDTH_C + (DATAWIDTH_C%2);	//Data Width
	localparam VW_C	= DW_C/2;				//Value Width
	localparam RW_C	= DW_C/2+1;				//Remainder Width
	localparam RN_C	= DW_C/2;				//Repeat Number
	
	//Define number and positions of pipeline registers
	localparam MaxPipelineNum_C = DW_C/2;
	localparam PipeRealNum_C = (PIPELINENUM_C > MaxPipelineNum_C)? MaxPipelineNum_C : PIPELINENUM_C;
	localparam PipeNum_C = (PIPELINENUM_C > MaxPipelineNum_C) ? MaxPipelineNum_C : ((PIPELINENUM_C > (MaxPipelineNum_C/2))? (MaxPipelineNum_C-PIPELINENUM_C) : PIPELINENUM_C);

	localparam RegItv_C = (PipeNum_C == 0) ? MaxPipelineNum_C : (MaxPipelineNum_C/PipeNum_C);
	localparam RegBitRemain_C = (PipeRealNum_C == MaxPipelineNum_C) ? 0 : (MaxPipelineNum_C - (RegItv_C * PipeNum_C));
	localparam [RegItv_C-1:0] RegBitElement_C = (PipeRealNum_C < (MaxPipelineNum_C/2)) ? {1'h1,{(RegItv_C-1){1'h0}}} : ((PipeRealNum_C == MaxPipelineNum_C) ? {PipeRealNum_C{1'h1}} : {{(RegItv_C-1){1'h1}},1'h0});
																							 
	localparam [RegItv_C:0] RegBitEleAdd_C = (PipeRealNum_C > (MaxPipelineNum_C/2)) ? {1'h1,RegBitElement_C} : {RegBitElement_C,1'h0} ;
	localparam [MaxPipelineNum_C-1 : 0] RegBit_C = (RegBitRemain_C == 0) ? {PipeRealNum_C {RegBitElement_C}} : (PipeRealNum_C > (MaxPipelineNum_C/2)) ?  {{(PipeNum_C - RegBitRemain_C){RegBitElement_C}},{RegBitRemain_C{RegBitEleAdd_C}}} : {{RegBitRemain_C{RegBitEleAdd_C}},{(PipeNum_C - RegBitRemain_C){RegBitElement_C}}};
		
	localparam [MaxPipelineNum_C-1 : 0] InRegBit_C = RegBit_C;
	localparam [MaxPipelineNum_C-1 : 0] OutRegBit_C = RegBit_C;
	localparam PN_C = PipeRealNum_C;
	
	//Define Port
	input sysclk;
	input reset_n;
	
	input [DInW_C-1:0] din;		//Data Input
	output [VW_C-1:0] vout;		//Value Output
	output [RW_C-1:0] rout;		//Remainder Output
	
	input clken;			//Clock Enable
	input calcen;			//Calculate Enable
	output sqrtidle;		//Value Available
	output calcend;			//Calculate End
		
	reg [PN_C-1:0] CalcEnSftReg;
	
	always @( posedge sysclk or negedge reset_n)
	begin
		if (!reset_n) begin
			CalcEnSftReg <= {PN_C{1'h0}};
		end
		else if (clken)	begin
			if (PN_C>1) begin		// updated 1-13-2020
				CalcEnSftReg[PN_C-2:0] <= CalcEnSftReg[PN_C-1:1];
			end
			CalcEnSftReg[PN_C-1] <= calcen;
		end
	end
	
	wire sqrtidle = 1'h1;		//Default 1: SQRT Idle
	wire calcend = CalcEnSftReg[0];
	wire InRegClkEn = clken;
	wire OutRegClkEn = clken;
	wire OutRegSync = 1'h0;
	
	wire [DW_C:0] Data = {{(DW_C-DInW_C+2){1'h0}},din};
	wire [DW_C:0] DRegIn [RN_C:0];
	wire [DW_C:0] DRegOut [RN_C:0];
	
	assign DRegIn [0][DW_C-1:0] = {Data[DW_C-3:0],2'h0};	
	assign DRegOut [0][DW_C-1:0] = {Data[DW_C-3:0],2'h0};	
	wire [1:0] AluIn [RN_C:0];
	assign AluIn[0][1:0] = Data[DW_C-1:DW_C-2];
	
	wire [RW_C+1:0] RemaDIn	[RN_C:0];
	wire [VW_C+1:0] ValueIn	[RN_C:0];
	
	assign RemaDIn[0][RW_C+1:0] = {(RW_C+2){1'h0}};	
	assign ValueIn[0][VW_C+1:0] = {(VW_C+2){1'h0}};
	
	wire [RW_C+1:0] RemaDOut [RN_C:0];
	wire [VW_C+1:0] ValueOut [RN_C:0];
	
	assign RemaDOut[0][RW_C+1:0] = {(RW_C+2){1'h0}};	
	assign ValueOut[0][VW_C+1:0] = {(VW_C+2){1'h0}};
	
	wire [RW_C+1:0] RemaDReg [RN_C:0];
	wire [VW_C+1:0] ValueReg [RN_C:0];
	
	assign RemaDReg[0][RW_C+1:0] = {(RW_C+2){1'h0}};	
	assign ValueReg[0][VW_C+1:0] = {(VW_C+2){1'h0}};
	
	wire [VW_C -1:0] Value;
	wire [RW_C -1:0] Remain;
	
	wire [VW_C-1:0] vout;		//Value Output
	wire [RW_C-1:0] rout;		//Remainder Output
	
	genvar i;
	generate		
		for (i=0; i<RN_C; i=i+1)
		begin : SqrtContin_Calculate
			/***************************************************/
			
			`IP_MODULE_NAME(DataReg) #( 
				.DataInWidth_C (DW_C), 
				.OutReg_C (InRegBit_C[i])
			)
			DataInReg (   
				//System Signal
				.sysclk (sysclk),
				.reset_n (reset_n),
				//Signal
				.clken (InRegClkEn),
				.SycnClr (1'h0),		//clear not enable
				.din (DRegIn[i][DW_C-1:0]),
				.DOut (DRegOut[i+1][DW_C-1:0])
			);
			
			assign DRegIn [i+1][DW_C-1:2] = DRegOut[i+1][DW_C-3:0];	
			assign DRegIn [i+1][1:0] = 2'h0;
			
			/****************************************************/ 
			assign AluIn[i+1][1:0] = DRegOut[i+1][DW_C-1:DW_C-2];
			
			assign RemaDIn[i+1][RW_C+1:i+3] = {RW_C-i-1{1'h0}};
			assign ValueIn[i+1][VW_C+1:i+2] = {VW_C-i  {1'h0}};
			
			assign RemaDIn[i+1][i+2:0] = RemaDReg[i+1][i+2:0];	
			assign ValueIn[i+1][i+1:0] = ValueReg[i+1][i+1:0];	
			
			`IP_MODULE_NAME(SqrtUnit) #(
				.ValueWidth(i+2)
			)
			SqrtCalc	
			(   
				.din (AluIn[i][1:0]),		//Data Input         
				.RIn (RemaDIn[i][i+2:0]),	//Last Remainder Input     
				.VIn (ValueIn[i][i+1:0]),	//Value Input        
				.rout (RemaDOut[i+1][i+2:0]),	//Remainder Output   
				.vout (ValueOut[i+1][i+1:0])	//Value Output       
			);      									 
			
			assign RemaDOut[i+1][RW_C+1:i+3] = {RW_C-i-1{1'h0}};
			assign ValueOut[i+1][VW_C+1:i+2] = {VW_C-i{1'h0}};
			
			/****************************************************/ 
			`IP_MODULE_NAME(DataReg) #(
				.DataInWidth_C (i+2),
				.OutReg_C (OutRegBit_C[i])
			)
			VOutReg	(   
				//System Signal
				.sysclk	(sysclk),		//System Clock
				.reset_n (reset_n),		//System Reset
				//Signal            						
				.clken (OutRegClkEn),		//Clock Eanble
				.SycnClr (OutRegSync),		//Sync Clear
				.din (ValueOut[i+1][i+1:0]),	//Data Input
				.DOut (ValueReg[i+1][i+1:0])	//Data Output
			);
			
			assign ValueReg[i+1][VW_C+1:i+2] = {(VW_C-i){1'h0}};
			
			/****************************************************/ 
			`IP_MODULE_NAME(DataReg) #(
				.DataInWidth_C (i+3),
				.OutReg_C (OutRegBit_C[i])
			)
			ROutReg	(   
				//System Signal
				.sysclk	(sysclk),		//System Clock
				.reset_n (reset_n),		//System Reset
				//Signal            						
				.clken (OutRegClkEn),		//Clock Eanble
				.SycnClr (OutRegSync),		//Sync Clear
				.din (RemaDOut[i+1][i+2:0]),	//Data Input
				.DOut (RemaDReg[i+1][i+2:0])	//Data Output
			);
			
			assign RemaDReg[i+1][RW_C+1:i+3] = {(RW_C-i){1'h0}};
			
			/****************************************************/ 
		end
	endgenerate
	
	assign vout = ValueReg[RN_C][VW_C-1:0];			//Value Output
	assign rout = RemaDReg[RN_C][RW_C-1:0];		//Remainder Output
	
endmodule 
	

/*
* Calculation module, combinational logics only
*/
module `IP_MODULE_NAME(SqrtUnit)
#(
 	//Define parameter
	parameter ValueWidth = 10
)

(   
	din,		//Data Input    
	RIn,		//Last Remainder Input     
	VIn,		//Value Input        
	rout,		//Remainder Output   
	vout		//Value Output       
);      	

	localparam VW_C = ValueWidth;
	localparam RW_C = ValueWidth + 1;
	localparam DW_C = ValueWidth + 2;
		
	//Define Port
	input [1:0] din;				//Data Input
	input [RW_C-1:0] RIn;				//Last Remainder Input     
	input [VW_C-1:0] VIn;				//Value Input	
	output [RW_C-1:0] rout;				//Remainder Output
	output [VW_C-1:0] vout;				//Value Output
			
	wire [DW_C:0] CalcV = {1'h0, VIn, 2'h1};	//VIn*4+1
	wire [DW_C:0] CalcD = {1'h0, RIn, din};		//RIn*4+din
	wire [DW_C:0] CalcR = CalcD - CalcV;		//RIn*4+din - VIn*4
	wire CalcF = ~CalcR[DW_C];			//CalcF=1 when RIn*4+din > VIn*4
	wire [RW_C-1:0]	rout = CalcF ? CalcR[RW_C-1:0] : CalcD[RW_C-1:0];		//Remainder Output
	wire [VW_C-1:0]	vout = CalcF ? {VIn[VW_C-2:0], CalcF} : {VIn[VW_C-2:0], 1'h0};	//Value Output
	
endmodule 


/*
* Input/output data register for pipelining
*/
module `IP_MODULE_NAME(DataReg)
#(
 	//Define parameter
	parameter DataInWidth_C = 6,
	parameter OutReg_C = 1
)

(   
	//System Signal
	sysclk,		//System Clock
	reset_n,	//System Reset
	//Signal
	clken,		//Clock Eanble
	SycnClr,	//Sync Clear
	din,		//Data Input
	DOut		//Data Output
);

	localparam DW_C = DataInWidth_C;
	
	//Define port
	input sysclk;
	input reset_n;
	input clken;
	input SycnClr;
	input [DW_C-1:0] din;
	output [DW_C-1:0] DOut;

	reg [DW_C-1:0] DOut;
	
	generate		
		if (OutReg_C) begin
			always @(posedge sysclk or negedge reset_n) begin
		  		if (!reset_n)
					DOut <= {DW_C{1'h0}};
		  		else if (SycnClr)
					DOut <= {DW_C{1'h0}};
	  			else if (clken)
					DOut <= din;
				else
					DOut <= DOut;	// added else condition
	  		end
		end
		else begin
			always @(din) begin
		  		DOut <= din;
		  	end
		end
	endgenerate
	
endmodule 
	

/*
* Busy signal when `IP_MODULE_NAME(SqrtUnit) in process
*/
module `IP_MODULE_NAME(SqrtCalcBusy)
#(
 	//Define parameter
	//parameter PIPELINENUM_C = 10
	parameter PIPELINENUM_C = 1
)

(   
	//System Signal
	sysclk,			//System Clock
	reset_n,		//System Reset
	//Signal
	CalcLast,		//Clock Enable
	calcen	,		//Calculate Enable
	CalcBusy,		//Calculate Busy
	calcend			//Calculate End
);

	localparam CntW_C = $clog2(PIPELINENUM_C) + 1;
	integer count=0;
	//Define port
	input sysclk;
	input reset_n;	
	output CalcLast;
	input calcen;
	output CalcBusy;
	output calcend;
	
	reg [CntW_C-1:0] CalcCnt; 
	reg CalcBusy; 
	
	always @(posedge sysclk or negedge reset_n) begin
		if (!reset_n)
			CalcCnt <= {CntW_C{1'h0}};
		else if (CalcBusy)
			CalcCnt <= CalcCnt - {{(CntW_C-1){1'h0}}, 1'h1};
		else if (calcen)
			CalcCnt <= PIPELINENUM_C - {{(CntW_C-1){1'h0}}, 1'h1};
		else
			CalcCnt <= CalcCnt;	// added else condition
	end
		
	always @(posedge sysclk or negedge reset_n) begin
		if (!reset_n)
			CalcBusy <= 1'h0;
		else if (calcen)
			CalcBusy <= 1'h1;
		else if (~|CalcCnt)
			CalcBusy <= 1'h0;
		else
			CalcBusy <= CalcBusy;	// added else condition
	end
	
	reg CalcLast;
	reg calcend;
	
	always @(posedge sysclk or negedge reset_n) begin
		if (!reset_n) begin
			CalcLast <= 1'h0;
			calcend <= 1'h0;
		end
		else if(calcen==1)begin
            if(count<11)begin
                CalcLast <= (CalcCnt == {{(CntW_C-1){1'h0}}, 1'h1});
                calcend <= CalcLast;
                count=count+1;
            end
            else begin
                calcend=0;
            end
		end
        else if(calcen==0)begin
            count=0;
        end
	end
	
endmodule 


/*
* module for single mode
*/	
module `IP_MODULE_NAME(SqrtSimple)
#(
 	//Define parameter
	parameter DATAWIDTH_C = 10,
	parameter ALUNUMBER = 3
)

(   
	//System Signal
	sysclk,		//System Clock
	reset_n,	//System Reset
	//Data Signal
	din,		//Data Input
	vout,		//Value Output
	rout,		//Remainder Output
	//Control & State Signal
	clken,		//Clock Eanble
	calcen,		//Calculate Enable
	calcend,	//Calculate End
	sqrtidle	//SQRT Idle
);

	localparam AN_C = ALUNUMBER;
	localparam DW_C = DATAWIDTH_C;
	
	localparam VW_C  = ((DW_C%2)+DW_C)/2;
	localparam RW_C = VW_C+1;
	
	localparam CalcDataWidth_C = (DW_C%(AN_C*2) == 0) ? DW_C : ((DW_C/(AN_C*2)+1)*(AN_C*2));
	
	localparam CDW_C = CalcDataWidth_C;	//Calculate Data Width	
	localparam CVW_C = CDW_C/2;		//Calculate Value Width
	localparam CRW_C = CVW_C+1;

	localparam RN_C = CDW_C/2/AN_C;		//Repeat Number
	localparam DGW_C = AN_C*2;		//Data Group Width
	
	//Define port
	input sysclk;
	input reset_n;
	input [DW_C-1:0] din;
	output [VW_C-1:0] vout;
	output [RW_C-1:0] rout;
	input clken;
	input calcen;
	output sqrtidle;
	output calcend;
	
	wire CalcEnable = calcen & clken;
	wire CalcBusy;
	wire calcend;
	wire CalcOutEn;
	
	defparam CalcState.PIPELINENUM_C = RN_C-1;

	`IP_MODULE_NAME(SqrtCalcBusy) CalcState
	(   
		//System Signal
		.sysclk (sysclk),
		.reset_n (reset_n),
		//Signal
		.CalcLast (CalcOutEn),
		.calcen (CalcEnable),
		.CalcBusy (CalcBusy),
		.calcend (calcend)
	);
		
	wire sqrtidle = ~CalcBusy;		//SQRT Idle when `IP_MODULE_NAME(SqrtUnit) is not busy
	
	wire [CDW_C-1:0] Data = {{(CDW_C-DW_C){1'h0}}, din};
	
	reg [CDW_C-DGW_C-1:0] DataReg;
	   
	always @(posedge sysclk or negedge reset_n) begin
		if (!reset_n)
			DataReg <= {CDW_C{1'h0}};
		else if (CalcBusy)
			DataReg <= DataReg << DGW_C;
		else if (CalcEnable)
			DataReg <= Data[CDW_C-DGW_C-1:0];
		else
			DataReg <= DataReg;	// added else condition
	end

	wire [CRW_C-1:0] RemaDOut[AN_C-1:0];
	wire [CVW_C-1:0] ValueOut[AN_C-1:0];
	wire [CRW_C-1:0] RemaDIn[AN_C:0];
	wire [CVW_C-1:0] ValueIn[AN_C:0];
		
	wire [1:0] AluIn[AN_C-1:0];
	
	genvar i;
	generate
		for (i=0; i<AN_C; i=i+1)
		begin: SqrtSingle_Calculate
			assign AluIn[i][1:0] = CalcBusy ? DataReg [CDW_C-DGW_C-i*2-1:CDW_C-DGW_C-i*2-2]	: Data [CDW_C-i*2-1:CDW_C-i*2-2];
																					
			`IP_MODULE_NAME(SqrtUnit) #(
				.ValueWidth(CVW_C)
			)
			SqrtCalc
			(   
				.din (AluIn[i][1:0]),         
				.RIn (RemaDIn[i][CRW_C-1:0]),     
				.VIn (ValueIn[i][CVW_C-1:0]),     
				.rout (RemaDOut[i][CRW_C-1:0]),
				.vout (ValueOut[i][CVW_C-1:0])       
			);      									 
			
			assign RemaDIn[i+1][CRW_C-1:0] = RemaDOut[i][CRW_C-1:0];	
			assign ValueIn[i+1][CVW_C-1:0] = ValueOut[i][CVW_C-1:0];	
		end
	endgenerate
	
	reg [CVW_C -1:0] ValueReg;
	reg [CRW_C -1:0] RemainReg;
		
	always @(posedge sysclk or negedge reset_n) begin
		if (!reset_n) begin
			ValueReg <= {CVW_C{1'h0}};
			RemainReg <= {CRW_C{1'h0}};
		end
		else if (CalcBusy | CalcEnable) begin
			RemainReg <= RemaDOut[AN_C-1][CRW_C-1:0];
			ValueReg <= ValueOut[AN_C-1][CVW_C-1:0];
		end
	end

	assign RemaDIn[0][CRW_C-1:0] = CalcBusy ? RemainReg : {CRW_C{1'h0}};	
	assign ValueIn[0][CVW_C-1:0] = CalcBusy ? ValueReg : {CVW_C{1'h0}};
	
	reg [VW_C-1:0] vout;
	reg [RW_C-1:0] rout;
	
	always @( posedge sysclk or negedge reset_n) begin
		if (!reset_n) begin
			vout <= {VW_C{1'h0}};	
			rout <= {RW_C{1'h0}};	
		end
		else if (CalcOutEn) begin
			rout <= RemaDOut[AN_C-1][CRW_C-1:0];
			vout <= ValueOut[AN_C-1][CVW_C-1:0];
		end
	end
	
endmodule 
	
//////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2019 Efinix Inc. All rights reserved.
//
// This   document  contains  proprietary information  which   is
// protected by  copyright. All rights  are reserved.  This notice
// refers to original work by Efinix, Inc. which may be derivitive
// of other work distributed under license of the authors.  In the
// case of derivative work, nothing in this notice overrides the
// original author's license agreement.  Where applicable, the 
// original license agreement is included in it's original 
// unmodified form immediately below this header.
//
// WARRANTY DISCLAIMER.  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND 
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH 
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES, 
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF 
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR 
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED 
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.
//
// LIMITATION OF LIABILITY.  
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY 
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT 
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY 
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT, 
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY 
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF 
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR 
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN 
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER 
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR 
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT 
//     APPLY TO LICENSEE.
//
/////////////////////////////////////////////////////////////////////////////
	

`undef IP_UUID
`undef IP_NAME_CONCAT
`undef IP_MODULE_NAME
